<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>ChatGPT-like AI Assistant</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Söhne:wght@400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">    
    <style>
        /* ChatGPT-like CSS Variables */
        :root {
            --primary-color: #10a37f;
            --primary-hover: #0d8b6e;
            --secondary-color: #6c757d;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --text-muted: #8e8ea0;
            --bg-primary: #ffffff;
            --bg-secondary: #f7f7f8;
            --bg-tertiary: #ececf1;
            --border-light: #e5e5e5;
            --border-medium: #d1d5db;
            --sidebar-bg: #f9f9f9;
            --sidebar-hover: #f0f0f0;
            --sidebar-active: #e7e7e7;
            --chat-user-bg: #f7f7f8;
            --chat-assistant-bg: #ffffff;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --radius-sm: 0.375rem;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
            --radius-xl: 1rem;
            --font-sans: 'Söhne', 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            --font-mono: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
        }

        /* Dark Mode Variables */
        .dark-mode {
            --text-primary: #ececf1;
            --text-secondary: #c5c5d2;
            --text-muted: #8e8ea0;
            --bg-primary: #212121;
            --bg-secondary: #2f2f2f;
            --bg-tertiary: #3c3c3c;
            --border-light: #3e3e3e;
            --border-medium: #4a4a4a;
            --sidebar-bg: #171717;
            --sidebar-hover: #2f2f2f;
            --sidebar-active: #3c3c3c;
            --chat-user-bg: #2f2f2f;
            --chat-assistant-bg: #212121;
        }

        /* Global Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-sans);
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            font-size: 14px;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar Styles */
        .sidebar {
            width: 260px;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--border-light);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            transition: all 0.3s ease;
            position: relative;
            z-index: 100;
        }

        .sidebar.collapsed {
            width: 0;
            min-width: 0;
            overflow: hidden;
        }

        .sidebar-header {
            padding: 18px 16px;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sidebar-logo {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sidebar-logo i {
            color: var(--primary-color);
            font-size: 20px;
        }

        .sidebar-toggle {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 16px;
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
        }

        .sidebar-toggle:hover {
            background-color: var(--sidebar-hover);
        }

        .new-chat-btn {
            margin: 16px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: var(--radius-md);
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
            font-size: 14px;
        }

        .new-chat-btn:hover {
            background-color: var(--primary-hover);
        }

        #chat-history-list {
            flex: 1;
            overflow-y: auto;
            padding: 0 8px;
            margin-bottom: 16px;
        }

        .chat-link {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 2px;
            border-radius: var(--radius-sm);
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .chat-link:hover {
            background-color: var(--sidebar-hover);
        }

        .chat-link.active {
            background-color: var(--sidebar-active);
            color: var(--text-primary);
        }

        .chat-link-actions {
            display: flex;
            gap: 4px;
            margin-left: auto;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .chat-link:hover .chat-link-actions {
            opacity: 1;
        }

        .chat-link-actions button {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 12px;
            cursor: pointer;
            padding: 4px;
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
        }

        .chat-link-actions button:hover {
            background-color: var(--sidebar-hover);
        }

        .sidebar-footer {
            padding: 16px;
            border-top: 1px solid var(--border-light);
        }

        .sidebar-btn {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 8px 12px;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            cursor: pointer;
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
            text-decoration: none;
            margin-bottom: 4px;
        }

        .sidebar-btn:hover {
            background-color: var(--sidebar-hover);
        }

        .sidebar-btn i {
            margin-right: 12px;
            width: 16px;
            text-align: center;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            margin-bottom: 8px;
            font-size: 13px;
            color: var(--text-secondary);
        }

        /* Main Content */
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-primary);
            position: relative;
            overflow: hidden;
        }

        .main.full-width {
            width: 100%;
        }

        /* Top Bar */
        .top-bar {
            padding: 16px 24px;
            background-color: var(--bg-primary);
            border-bottom: 1px solid var(--border-light);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .top-bar-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .top-bar-title i {
            color: var(--primary-color);
            font-size: 20px;
        }

        .top-bar-actions {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 16px;
            cursor: pointer;
            width: 32px;
            height: 32px;
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .action-btn:hover {
            background-color: var(--bg-secondary);
        }

        /* Chat Container */
        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .chat-container::-webkit-scrollbar {
            width: 4px;
        }

        .chat-container::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-container::-webkit-scrollbar-thumb {
            background-color: var(--border-medium);
            border-radius: 2px;
        }

        /* Chat Messages */
        .chat-message {
            max-width: 768px;
            margin: 0 auto;
            width: 100%;
            padding: 24px;
            border-radius: var(--radius-lg);
            position: relative;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .user-message {
            background-color: var(--chat-user-bg);
            border: 1px solid var(--border-light);
        }

        .bot-message {
            background-color: var(--chat-assistant-bg);
            border: 1px solid var(--border-light);
        }

        .message-header {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
        }

        .message-header i {
            margin-right: 8px;
            color: var(--primary-color);
        }

        .message-timestamp {
            font-weight: 400;
            font-size: 12px;
            color: var(--text-muted);
            margin-left: auto;
        }

        .message-content {
            color: var(--text-primary);
            line-height: 1.7;
        }

        .message-content p {
            margin-bottom: 12px;
        }

        .message-content p:last-child {
            margin-bottom: 0;
        }

        /* Code Blocks */
        .code-block {
            margin: 16px 0;
            border-radius: var(--radius-md);
            overflow: hidden;
            background-color: #1a1a1a;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background-color: #2d2d2d;
            border-bottom: 1px solid #404040;
        }

        .code-language {
            font-size: 12px;
            font-weight: 500;
            color: #a0a0a0;
        }

        .copy-btn {
            background: none;
            border: none;
            color: #a0a0a0;
            font-size: 12px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
        }

        .copy-btn:hover {
            background-color: #404040;
            color: white;
        }

        pre {
            background-color: #1a1a1a !important;
            padding: 16px !important;
            margin: 0 !important;
            overflow-x: auto;
            font-family: var(--font-mono);
            font-size: 13px;
            line-height: 1.5;
        }

        /* Input Area */
        .input-area {
            padding: 24px;
            background-color: var(--bg-primary);
            border-top: 1px solid var(--border-light);
        }

        .input-container {
            max-width: 768px;
            margin: 0 auto;
            display: flex;
            gap: 8px;
            align-items: flex-end;
        }

        .model-select-group {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-light);
        }

        .model-select-group label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }

        .model-select-group label:hover {
            color: var(--text-primary);
        }

        .model-select-group input[type="radio"] {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-medium);
            border-radius: 50%;
            margin-right: 8px;
            transition: all 0.2s ease;
        }

        .model-select-group input[type="radio"]:checked {
            border-color: var(--primary-color);
            background-color: var(--primary-color);
        }

        .model-select-group input[type="radio"]:checked::before {
            content: '';
            display: block;
            width: 6px;
            height: 6px;
            background-color: white;
            border-radius: 50%;
            position: relative;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #text-input {
            flex: 1;
            min-height: 48px;
            max-height: 200px;
            padding: 12px 16px;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-lg);
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-size: 14px;
            font-family: var(--font-sans);
            resize: none;
            outline: none;
            transition: all 0.2s ease;
        }

        #text-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(16, 163, 127, 0.1);
        }

        .file-input-label,
        #voice-talk-btn {
            width: 48px;
            height: 48px;
            border-radius: var(--radius-lg);
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-light);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-secondary);
        }

        .file-input-label:hover,
        #voice-talk-btn:hover {
            background-color: var(--bg-tertiary);
            border-color: var(--border-medium);
        }

        #web-search-btn {
            padding: 12px 16px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-lg);
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #web-search-btn:hover {
            background-color: var(--bg-tertiary);
            border-color: var(--border-medium);
        }

        .submit-btn,
        .stop-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: var(--radius-lg);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .submit-btn:hover {
            background-color: var(--primary-hover);
        }

        .stop-btn {
            background-color: #ef4444;
            display: none;
        }

        .stop-btn:hover {
            background-color: #dc2626;
        }

        /* Loading Indicator */
        .loader {
            display: none;
            padding: 16px;
            text-align: center;
        }

        .typing-indicator {
            display: flex;
            justify-content: center;
            gap: 4px;
            padding: 8px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            background-color: var(--primary-color);
            border-radius: 50%;
            animation: typingAnimation 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(1) { animation-delay: 0s; }
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typingAnimation {
            0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
            30% { transform: translateY(-8px); opacity: 1; }
        }

        /* Floating Sidebar Button */
        #showSidebarBtn {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--radius-lg);
            font-size: 16px;
            cursor: pointer;
            box-shadow: var(--shadow-md);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        #showSidebarBtn:hover {
            background-color: var(--primary-hover);
            transform: scale(1.05);
        }

        /* Image Preview */
        .image-preview-container {
            display: none;
            max-width: 768px;
            margin: 0 auto 16px;
            padding: 16px;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-lg);
            background-color: var(--bg-secondary);
        }

        .image-preview-container img {
            max-width: 200px;
            max-height: 200px;
            border-radius: var(--radius-md);
            object-fit: cover;
        }

        .clear-image-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            font-size: 12px;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: var(--bg-primary);
            padding: 24px;
            border-radius: var(--radius-xl);
            max-width: 90%;
            width: 400px;
            box-shadow: var(--shadow-lg);
        }

        .modal-content h3 {
            margin-bottom: 16px;
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
        }

        .modal-content p {
            margin-bottom: 24px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 8px 16px;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .modal-btn.cancel {
            background-color: var(--bg-secondary);
            color: var(--text-secondary);
        }

        .modal-btn.cancel:hover {
            background-color: var(--bg-tertiary);
        }

        .modal-btn.confirm {
            background-color: #ef4444;
            color: white;
            border-color: #ef4444;
        }

        .modal-btn.confirm:hover {
            background-color: #dc2626;
        }

        /* Camera Options */
        .camera-options {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--bg-primary);
            border-top: 1px solid var(--border-light);
            border-radius: var(--radius-xl) var(--radius-xl) 0 0;
            box-shadow: var(--shadow-lg);
            z-index: 1000;
            padding: 24px;
        }

        .camera-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px;
            margin-bottom: 8px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .camera-option:hover {
            background-color: var(--bg-tertiary);
        }

        .camera-option.cancel {
            background-color: #fef2f2;
            border-color: #fecaca;
            color: #dc2626;
        }

        .camera-option.cancel:hover {
            background-color: #fee2e2;
        }

        .camera-option input[type="file"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
            z-index: 1;
        }

        /* Voice Mode Overlay */
        #voice-mode-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        #voice-mode-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        #voice-mode-overlay .status-text {
            font-size: 18px;
            margin-bottom: 32px;
            color: #a0a0a0;
        }

        #voice-circle-canvas {
            border-radius: 50%;
            margin-bottom: 32px;
        }

        #voice-mode-overlay .control-buttons {
            display: flex;
            gap: 16px;
        }

        #voice-mode-overlay .control-button {
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            border-radius: 50%;
            width: 64px;
            height: 64px;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #voice-mode-overlay .control-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        #voice-mode-overlay .control-button.mic-active {
            background-color: var(--primary-color);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                height: 100vh;
                z-index: 100;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
            }

            .sidebar.visible {
                transform: translateX(0);
            }

            .main {
                margin-left: 0;
            }

            #showSidebarBtn {
                display: flex;
            }

            .chat-container {
                padding: 16px;
            }

            .chat-message {
                padding: 16px;
            }

            .input-area {
                padding: 16px;
            }

            .input-container {
                flex-wrap: wrap;
                gap: 8px;
            }

            #text-input {
                width: 100%;
                order: 1;
            }

            .file-input-label,
            #voice-talk-btn {
                order: 2;
            }

            #web-search-btn {
                order: 3;
                flex: 1;
            }

            .submit-btn,
            .stop-btn {
                order: 4;
                flex: 1;
            }

            .model-select-group {
                flex-direction: column;
                gap: 12px;
                align-items: flex-start;
            }
        }

        /* Full Screen Mode */
        body.full-screen-mode .sidebar {
            transform: translateX(-100%);
        }

        body.full-screen-mode .main {
            margin-left: 0;
            width: 100%;
        }

        body.full-screen-mode #showSidebarBtn {
            display: flex;
        }

        /* Additional utility classes */
        .pulse {
            animation: pulse 0.5s ease;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        .fadeIn {
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Voice indicator area */
        .voice-indicator-area {
            flex: 1;
            min-height: 48px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-lg);
            display: none;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .input-container.voice-active .voice-indicator-area {
            display: flex;
        }

        #voice-status-text {
            font-size: 14px;
            color: var(--text-secondary);
        }

        /* Message images */
        .message-images-container {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 12px;
        }

        .message-images-container img,
        .uploaded-image-preview {
            max-width: 100%;
            max-height: 300px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-light);
            object-fit: contain;
        }

        /* Message actions */
        .message-actions {
            margin-top: 12px;
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .message-action-btn {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border: 1px solid var(--border-light);
            padding: 6px 12px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .message-action-btn:hover {
            background-color: var(--bg-tertiary);
        }

        /* Section styling */
        .message-section {
            margin-bottom: 16px;
        }

        .section-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .example-item {
            background-color: var(--bg-secondary);
            padding: 12px;
            border-radius: var(--radius-md);
            margin-bottom: 8px;
            border-left: 3px solid var(--primary-color);
            transition: all 0.2s ease;
        }

        .example-item:hover {
            background-color: var(--bg-tertiary);
        }

        .example-title {
            font-weight: 500;
            margin-bottom: 4px;
            color: var(--text-primary);
        }

        /* Code update modal */
        #codeUpdateModal .modal-content {
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        #codeUpdateModal textarea {
            flex: 1;
            min-height: 200px;
            padding: 12px;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            font-family: var(--font-mono);
            font-size: 13px;
            resize: vertical;
        }

        #codeUpdateModal select {
            padding: 8px 12px;
            margin-bottom: 16px;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }

        /* Screen share preview */
        #screen-share-preview-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 999;
            display: none;
            justify-content: center;
            align-items: center;
        }

        #screen-share-preview-video {
            max-width: 90%;
            max-height: 90%;
            border: 2px solid var(--primary-color);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 12px;
            border-radius: var(--radius-sm);
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 100;
            margin-bottom: 8px;
        }

        .tooltip-container:hover .tooltip {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="sidebar" class="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-logo">
                <i class="fas fa-robot"></i>
                <span>ChatGPT</span>
            </div>
            <!-- Renamed hideSidebarBtn to sidebarToggleButton for general use -->
            <button id="sidebarToggleButton" class="sidebar-toggle" title="Toggle Sidebar">
                <i class="fas fa-times"></i>
            </button>
        </div>

        <button class="new-chat-btn" onclick="startNewChat()">
            <i class="fas fa-plus"></i>
            <span>New Chat</span>
        </button>

        <div id="chat-history-list"></div>

        <div class="sidebar-footer">
            <div id="user-info" class="user-info" style="display: none;">
                <i class="fas fa-user-circle"></i>
                <span id="user-email" class="user-email"></span>
            </div>
            <button class="sidebar-btn" onclick="toggleDarkMode()" title="Toggle Dark Mode">
                <i class="fas fa-moon"></i>
                <span>Dark theme</span>
            </button>
            <button class="sidebar-btn" id="clearAllChatsBtn" title="Clear conversations">
                <i class="fas fa-trash"></i>
                <span>Clear conversations</span>
            </button>
            <a href="/logout" class="sidebar-btn" style="color: #ff6b6b;" title="Logout">
                <i class="fas fa-sign-out-alt"></i>
                <span>Logout</span>
            </a>
        </div>
    </div>

    <!-- Floating button to show sidebar on mobile or in full screen mode -->
    <button id="showSidebarBtn" class="sidebar-show-btn" title="Show Sidebar">
        <i class="fas fa-bars"></i>
    </button>

    <div class="main">
        <div class="top-bar">
            <div class="top-bar-title">
                <i class="fas fa-robot"></i>
                <span>ChatGPT</span>
            </div>
            <div class="top-bar-actions">
                <button class="action-btn" onclick="toggleDarkMode()" title="Toggle Dark Mode">
                    <i class="fas fa-moon"></i>
                </button>
                <button class="action-btn full-screen-btn" onclick="toggleFullScreen()" title="Toggle Full Screen">
                    <i class="fas fa-expand"></i>
                    <span class="tooltip">Toggle Full Screen</span>
                </button>
            </div>
        </div>

        <div class="chat-container" id="chatbox"></div>

        <!-- Input Area at the bottom -->
        <div class="input-area">
            <!-- Image Preview Container -->
            <div id="image-preview-container" class="image-preview-container">
                <img id="image-preview" src="#" alt="Image Preview" style="display: none;">
                <button id="clear-image-btn" class="clear-image-btn" title="Clear Image">
                    <i class="fas fa-times"></i>
                </button>
            </div>

            <form id="multi-action-form" enctype="multipart/form-data">
                <!-- Model Selection Radio Buttons -->
                <div class="model-select-group">
                    <label for="modelGeneral">
                        <input type="radio" id="modelGeneral" name="modelChoice" value="general" checked>
                        GPT-4o
                    </label>
                    <label for="modelDeepThink">
                        <input type="radio" id="modelDeepThink" name="modelChoice" value="deep_think">
                        o1-preview
                    </label>
                </div>

                <div class="input-container">
                    <textarea id="text-input" name="instruction" placeholder="Message ChatGPT" rows="1" required></textarea>
                    
                    <!-- Original file-input-label now acts as the trigger for camera options -->
                    <label for="file-input-trigger" class="file-input-label" id="file-input-label">
                        <i class="fas fa-paperclip"></i>
                        <!-- No actual file input here anymore, just a trigger -->
                    </label>
                    <!-- Removed the original file-input from here -->

                    <button type="button" id="web-search-btn" title="Search the web">
                        <i class="fas fa-globe"></i>
                        <span>Search</span>
                    </button>

                    <!-- NEW: Voice Talk Button -->
                    <button type="button" id="voice-talk-btn" title="Toggle Voice Talk">
                        <i class="fas fa-microphone"></i>
                    </button>
                
                    <button type="submit" class="submit-btn" id="send-btn" title="Send Message">
                        <i class="fas fa-paper-plane"></i>
                        <span>Send</span>
                    </button>
                    <!-- NEW: Stop Response Button -->
                    <button type="button" class="stop-btn" id="stop-btn" title="Stop Response">
                        <i class="fas fa-stop"></i>
                        <span>Stop</span>
                    </button>

                    <!-- Voice Indicator Area (for input bar when not in full voice mode) -->
                    <div id="voice-indicator-area" class="voice-indicator-area">
                        <div class="typing-indicator">
                            <div class="typing-dot"></div>
                            <div class="typing-dot"></div>
                            <div class="typing-dot"></div>
                        </div>
                        <span id="voice-status-text"></span>
                    </div>
                </div>
            </form>
        </div>

        <!-- Loading Indicator -->
        <div class="loader" id="loader">
            <div class="typing-indicator">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
            </div>
        </div>
    </div>

    <!-- NEW: Voice Mode Full-Screen Overlay -->
    <div id="voice-mode-overlay">
        <div class="status-text">Standard voice</div>
        <canvas id="voice-circle-canvas"></canvas>
        <div class="control-buttons">
            <button id="mic-control-btn" class="control-button">
                <i class="fas fa-microphone"></i>
            </button>
            <button id="screen-share-btn" class="control-button" title="Toggle Screen Share">
                <i class="fas fa-desktop"></i>
            </button>
            <button id="close-voice-mode-btn" class="control-button">
                <i class="fas fa-times"></i>
            </button>
        </div>
    </div>

    <!-- NEW: Screen Share Preview Container -->
    <div id="screen-share-preview-container">
        <video id="screen-share-preview-video" autoplay></video>
    </div>

    <!-- Confirmation Modal for Clear All Chats -->
    <div id="confirmModal" class="modal">
        <div class="modal-content">
            <h3>Clear conversations?</h3>
            <p>This will clear all your conversations and cannot be undone.</p>
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="hideModal()">Cancel</button>
                <button class="modal-btn confirm" id="confirmClearBtn">Clear</button>
            </div>
        </div>
    </div>

    <!-- NEW: Code Update Modal -->
    <div id="codeUpdateModal" class="modal">
        <div class="modal-content">
            <h3>Update Code File</h3>
            <p>Paste the updated code below. Select the file to update (e.g., `index.html` or `test.py`).</p>
            <select id="fileToUpdateSelect">
                <option value="index.html">index.html (Frontend HTML/JS)</option>
                <option value="test.py">test.py (Backend Python)</option>
                <option value="script.py">script.py (Backend Python - if applicable)</option>
            </select>
            <textarea id="codeUpdateTextarea" placeholder="Paste your updated code here..."></textarea>
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="document.getElementById('codeUpdateModal').style.display='none';">Cancel</button>
                <button class="modal-btn confirm" id="applyCodeUpdateBtn">Apply Update</button>
            </div>
        </div>
    </div>

    <!-- Camera Options (for mobile file upload) -->
    <div class="camera-options">
        <div class="camera-option" id="take-photo">
            <i class="fas fa-camera"></i>
            <span>Take a photo</span>
            <!-- Hidden input directly inside the clickable area -->
            <input type="file" id="take-photo-input" name="image" accept="image/*" capture="environment"/>
        </div>
        <div class="camera-option" id="upload-photo">
            <i class="fas fa-image"></i>
            <span>Choose from library</span>
            <!-- Hidden input directly inside the clickable area -->
            <input type="file" id="upload-photo-input" name="image" accept="image/*"/>
        </div>
        <div class="camera-option cancel" id="cancel-camera">
            <i class="fas fa-times"></i>
            <span>Cancel</span>
        </div>
    </div>

    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.0/marked.min.js"></script>
    <script>
        // Global variables for chat management
        let currentChatId = null;
        let sidebarHidden = false; // Tracks if sidebar is manually collapsed on desktop
        let isFullScreen = false; // Tracks if full screen chat mode is active
        let abortController = null; // Global AbortController for stopping AI responses

        // Voice Talk Globals
        let recognition;
        let synth = window.speechSynthesis;
        let isVoiceTalkActive = false; // Controls the full-screen voice overlay
        let isListening = false; // Controls SpeechRecognition state
        let isSpeaking = false; // Controls SpeechSynthesis state
        let pendingBotSpeechText = ""; // Global to hold the actual text that will be displayed after speaking
        let speechQueue = []; // Queue for streaming speech synthesis
        let isProcessingSpeechQueue = false; // Flag to manage speech queue processing
        let selectedVoice = null; // Stores the selected voice for AI speech

        // Web Audio API for visualizer
        let audioContext;
        let analyser;
        let microphoneStream;
        let animationFrameId;
        let canvas, canvasCtx;
        let bufferLength;
        let dataArray;
        // let aiVoiceSource; // Not directly used as SpeechSynthesis doesn't expose an audio source node

        // Screen Share Globals
        let screenShareStream = null;
        let screenShareInterval = null;
        let isScreenSharing = false;
        const screenCaptureCanvas = document.createElement('canvas'); // Off-screen canvas
        const screenCaptureCtx = screenCaptureCanvas.getContext('2d');
        const screenShareVideoElement = document.getElementById('screen-share-preview-video');
        const screenSharePreviewContainer = document.getElementById('screen-share-preview-container');

        // Helper Functions
        function scrollToBottom() {
            const chatbox = document.getElementById('chatbox');
            chatbox.scrollTop = chatbox.scrollHeight;
        }

        // Function to escape HTML entities for display within a text area or code block
        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // Custom Marked.js Renderer for Code Blocks
        const renderer = new marked.Renderer();
        renderer.code = function(code, lang, escaped) {
            const language = lang || 'plaintext';
            // The 'code' parameter here is already unescaped by marked.js.
            // We need to re-escape it to ensure it's displayed as raw text within <pre><code>.
            const codeToDisplay = escapeHtml(code); 

            return `
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">${language.toUpperCase()}</span>
                        <button class="copy-btn" onclick="copyToClipboard(this)">
                            <i class="far fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre><code class="language-${language}">${codeToDisplay}</code></pre>
                </div>
            `;
        };
        // Override for paragraph rendering to add default margins
        renderer.paragraph = function(text) {
            return `<p>${text}</p>`;
        };

        marked.setOptions({
            breaks: true, // Allow GFM line breaks
            highlight: function(code, lang) {
                const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                return hljs.highlight(code, { language }).value;
            },
            renderer: renderer // Use our custom renderer
        });

        // Function to copy code to clipboard
        window.copyToClipboard = function(button) {
            const codeBlock = button.closest('.code-block').querySelector('code');
            if (codeBlock) {
                const textToCopy = codeBlock.textContent || codeBlock.innerText;

                // Create a temporary textarea element to hold the text
                const tempTextArea = document.createElement('textarea');
                tempTextArea.value = textToCopy;
                tempTextArea.style.position = 'fixed'; // Prevent scrolling to bottom of page
                tempTextArea.style.left = '-9999px'; // Move off-screen
                tempTextArea.style.top = '0';
                document.body.appendChild(tempTextArea);

                // Select the text in the textarea
                tempTextArea.focus();
                tempTextArea.select();

                try {
                    // Execute the copy command
                    const successful = document.execCommand('copy');
                    if (successful) {
                        button.innerHTML = '<i class="fas fa-check"></i> Copied!';
                        setTimeout(() => {
                            button.innerHTML = '<i class="far fa-copy"></i> Copy';
                        }, 2000);
                    } else {
                        // Fallback for modern browsers if execCommand fails (e.g., due to restrictions)
                        // This part might still fail in strict iframe environments, but it's the standard fallback.
                        navigator.clipboard.writeText(textToCopy).then(() => {
                            button.innerHTML = '<i class="fas fa-check"></i> Copied!';
                            setTimeout(() => {
                                button.innerHTML = '<i class="far fa-copy"></i> Copy';
                            }, 2000);
                        }).catch(err => {
                            console.error('Failed to copy text using navigator.clipboard:', err);
                            // Provide user feedback if both methods fail
                            button.innerHTML = '<i class="fas fa-times"></i> Failed';
                            setTimeout(() => {
                                button.innerHTML = '<i class="far fa-copy"></i> Copy';
                            }, 2000);
                        });
                    }
                } catch (err) {
                    console.error('Failed to copy text using document.execCommand:', err);
                    // Fallback to navigator.clipboard if execCommand throws an error
                    navigator.clipboard.writeText(textToCopy).then(() => {
                        button.innerHTML = '<i class="fas fa-check"></i> Copied!';
                        setTimeout(() => {
                            button.innerHTML = '<i class="far fa-copy"></i> Copy';
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy text using navigator.clipboard (fallback):', err);
                        button.innerHTML = '<i class="fas fa-times"></i> Failed';
                        setTimeout(() => {
                            button.innerHTML = '<i class="far fa-copy"></i> Copy';
                        }, 2000);
                    });
                } finally {
                    // Clean up the temporary textarea
                    document.body.removeChild(tempTextArea);
                }
            }
        };

        // Function to add a new message to the chatbox
        function addMessage(text, type = 'bot', optionalContent = null, timestamp = new Date()) {
            const chatbox = document.getElementById('chatbox');
            const msg = document.createElement('div');
            msg.className = `chat-message ${type}-message pulse`; // Add pulse animation class
            
            const header = document.createElement('div');
            header.className = 'message-header';
            header.innerHTML = type === 'user' ? '<i class="fas fa-user"></i> You' : '<i class="fas fa-robot"></i> Vexara';
            
            const timestampSpan = document.createElement('span');
            timestampSpan.className = 'message-timestamp';
            timestampSpan.textContent = timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            header.appendChild(timestampSpan);
            msg.appendChild(header);
            
            const content = document.createElement('div');
            content.className = 'message-content';
            // Warn if text content is unexpectedly empty for user messages
            if (type === 'user' && !text.trim()) {
                console.warn("User message text is empty. This might indicate an issue with backend message storage.");
                content.innerHTML = "*(No text provided)*"; // Placeholder for empty text
            } else {
                content.innerHTML = marked.parse(text); // Parse markdown content
            }
            msg.appendChild(content);

            // Append optional content (e.g., uploaded image or generated images)
            if (optionalContent) {
                if (optionalContent instanceof HTMLElement) {
                    msg.appendChild(optionalContent);
                } else if (Array.isArray(optionalContent)) {
                    const imageContainer = document.createElement('div');
                    imageContainer.className = 'message-images-container';
                    optionalContent.forEach(imageUrl => {
                        const imgElement = document.createElement('img');
                        imgElement.src = imageUrl;
                        imgElement.alt = "Generated Image";
                        imageContainer.appendChild(imgElement);
                    });
                    msg.appendChild(imageContainer);
                }
            }
            
            chatbox.appendChild(msg);
            scrollToBottom();

            // Highlight code blocks after adding message
            document.querySelectorAll('.chat-message code').forEach((block) => {
                try {
                    hljs.highlightElement(block);
                } catch (e) {
                    console.warn("Highlight.js failed on block:", block, e);
                    block.style.color = 'var(--code-text-color)'; 
                }
            });
        }

        // Function to simulate typing effect for bot messages
        // This function is now responsible for creating the initial message container
        // and updating its content as chunks arrive.
        let currentBotMessageElement = null; // Reference to the current bot message being typed
        let currentBotMessageContentDiv = null; // Reference to the content div within that message
        let currentBotMessageFullText = ""; // Accumulates the full text for saving/actions

        // Global/module-level declaration for sentence detector
        const sentenceRegex = /[^.!?]+[.!?]+/g; // Moved to global scope

        function createStreamingBotMessage(timestamp = new Date()) {
            const chatbox = document.getElementById('chatbox');
            const msg = document.createElement('div');
            msg.className = `chat-message bot-message`; // No pulse on typing init
            
            const header = document.createElement('div');
            header.className = 'message-header';
            header.innerHTML = '<i class="fas fa-robot"></i> Vexara';
            
            const timestampSpan = document.createElement('span');
            timestampSpan.className = 'message-timestamp';
            timestampSpan.textContent = timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            header.appendChild(timestampSpan);
            msg.appendChild(header);

            currentBotMessageContentDiv = document.createElement('div');
            currentBotMessageContentDiv.className = 'message-content';
            msg.appendChild(currentBotMessageContentDiv);

            chatbox.appendChild(msg);
            scrollToBottom();

            currentBotMessageElement = msg; // Store reference to the new message element
            currentBotMessageFullText = ""; // Reset full text accumulator
            pendingBotSpeechText = ""; // Ensure pending speech text is cleared for new message
            sentenceRegex.lastIndex = 0; // Reset regex state for new message
        }

        async function appendToStreamingBotMessage(chunk) {
            if (!currentBotMessageContentDiv) {
                console.error("No active bot message element to append to.");
                return;
            }

            currentBotMessageFullText += chunk;

            // If voice talk is active, try to speak chunks as sentences
            if (isVoiceTalkActive) {
                pendingBotSpeechText += chunk;
                let lastSpokenIndex = 0; // Track the end index of the last spoken sentence
                
                // Reset lastIndex for each new processing cycle of pendingBotSpeechText
                // This is crucial because pendingBotSpeechText is modified.
                sentenceRegex.lastIndex = 0; 
                let match;
                
                // Loop to find all complete sentences in the current pendingBotSpeechText
                while ((match = sentenceRegex.exec(pendingBotSpeechText)) !== null) {
                    const sentence = match[0].trim();
                    if (sentence) {
                        speakText(sentence);
                        lastSpokenIndex = sentenceRegex.lastIndex; // Store the index up to which we've spoken
                    }
                }

                // Remove the spoken sentences from the beginning of pendingBotSpeechText
                if (lastSpokenIndex > 0) {
                    pendingBotSpeechText = pendingBotSpeechText.substring(lastSpokenIndex);
                }
                // No need to reset sentenceRegex.lastIndex here, it will be reset at the start of the next call.

            } else {
                // If not voice active, update content directly for visual typing effect
                currentBotMessageContentDiv.innerHTML = marked.parse(currentBotMessageFullText);
                
                currentBotMessageContentDiv.querySelectorAll('pre code').forEach((block) => {
                    try {
                        hljs.highlightElement(block);
                    } catch (e) {
                        console.warn("Highlight.js failed on block during streaming:", block, e);
                        block.style.color = 'var(--code-text-color)'; 
                    }
                });
            }
            
            scrollToBottom();
        }

        async function finalizeStreamingBotMessage(image_urls = []) {
            if (!currentBotMessageElement) {
                console.error("No active bot message element to finalize.");
                return;
            }

            // Speak any remaining pending text if voice talk is active
            if (isVoiceTalkActive && pendingBotSpeechText) {
                await new Promise(resolve => {
                    const finalUtterance = new SpeechSynthesisUtterance(pendingBotSpeechText);
                    finalUtterance.lang = 'en-US';
                    finalUtterance.pitch = 1.0; // Default pitch
                    finalUtterance.rate = 1.0; // Default rate
                    finalUtterance.voice = selectedVoice; // Apply selected voice
                    finalUtterance.onend = resolve;
                    finalUtterance.onerror = resolve; // Resolve even on error to finalize message
                    synth.speak(finalUtterance);
                });
            }

            // Ensure the content is displayed if it wasn't during streaming (e.g., voice mode was active)
            if (currentBotMessageContentDiv && currentBotMessageContentDiv.innerHTML === '' && currentBotMessageFullText) {
                currentBotMessageContentDiv.innerHTML = marked.parse(currentBotMessageFullText);
                currentBotMessageContentDiv.querySelectorAll('pre code').forEach((block) => {
                    try {
                        hljs.highlightElement(block);
                    } catch (e) {
                        console.warn("Highlight.js failed on block during streaming (finalize):", block, e);
                        block.style.color = 'var(--code-text-color)'; 
                    }
                });
            }

            // Append images
            if (image_urls && image_urls.length > 0) {
                const imageContainer = document.createElement('div');
                imageContainer.className = 'message-images-container';
                image_urls.forEach(imageUrl => {
                    const imgElement = document.createElement('img');
                    imgElement.src = imageUrl;
                    imgElement.alt = "Generated Image";
                    imageContainer.appendChild(imgElement);
                });
                currentBotMessageElement.appendChild(imageContainer);
                scrollToBottom();
            }

            // Add action buttons
            if (currentBotMessageFullText.length > 100) {
                const messageActionsDiv = document.createElement('div');
                messageActionsDiv.className = 'message-actions';

                const summarizeButton = document.createElement('button');
                summarizeButton.className = 'message-action-btn';
                summarizeButton.innerHTML = '<i class="fas fa-sparkle"></i> Summarize';
                summarizeButton.onclick = async () => {
                    summarizeButton.disabled = true;
                    summarizeButton.innerHTML = '<i class="fas fa-hourglass-half"></i> Summarizing...';
                    const summary = await summarizeText(currentBotMessageFullText);
                    if (summary) {
                        addMessage(`**Summary:** ${summary}`, 'bot', null, new Date());
                    }
                    summarizeButton.disabled = false;
                    summarizeButton.innerHTML = '<i class="fas fa-sparkle"></i> Summarize';
                };
                messageActionsDiv.appendChild(summarizeButton);
                currentBotMessageElement.appendChild(messageActionsDiv);
            }

            // Clear references
            currentBotMessageElement = null;
            currentBotMessageContentDiv = null;
            currentBotMessageFullText = "";
            pendingBotSpeechText = ""; // Ensure this is cleared here too
            sentenceRegex.lastIndex = 0; // Ensure regex state is reset on finalization
            scrollToBottom(); // Final scroll to ensure everything is visible

            // If voice mode is active, restart listening after AI finishes speaking
            if (isVoiceTalkActive) {
                startListening();
            }
        }


        // AI Function Calls (stubs, assume backend handles actual API calls)
        async function askAI(instruction, modelChoice) { // Added modelChoice parameter
            const textInput = document.getElementById('text-input');
            const loader = document.getElementById('loader');

            // Show loader BEFORE creating the streaming message
            loader.style.display = 'block'; 
            showStopButton(); // Show stop button, hide send button
            stopSpeaking(); // Stop AI speech if any

            // Initialize AbortController for this request
            abortController = new AbortController();
            const signal = abortController.signal;

            try {
                const formData = new FormData();
                formData.append('instruction', instruction);
                formData.append('chat_id', currentChatId);
                formData.append('model_choice', modelChoice); // Append model choice

                const response = await fetch(`${window.location.origin}/ask`, {
                    method: 'POST',
                    body: formData,
                    signal: signal // Pass the abort signal to the fetch request
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Server error: ${response.status} ${response.statusText} - ${errorText}`);
                }

                // Hide loader once the actual streaming starts
                loader.style.display = 'none'; 

                // Create the initial message container for streaming
                createStreamingBotMessage(new Date());

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let done = false;

                while (!done) {
                    const { value, done: readerDone } = await reader.read();
                    done = readerDone;
                    const chunk = decoder.decode(value, { stream: true });
                    if (chunk) {
                        await appendToStreamingBotMessage(chunk);
                    }
                }
                
                // Finalize the streaming message after stream finishes
                finalizeStreamingBotMessage(); 

            } catch (error) {
                loader.style.display = 'none'; // Hide loader on error
                if (error.name === 'AbortError') {
                    console.log('Fetch aborted by user.');
                    if (currentBotMessageContentDiv) {
                        currentBotMessageContentDiv.innerHTML += `<p>*(Response stopped by user)*</p>`;
                    } else {
                        addMessage(`Response stopped by user.`, 'bot', null, new Date());
                    }
                } else {
                    console.error("Error asking AI:", error);
                    // If an error occurs, ensure the message is still added or updated
                    if (currentBotMessageContentDiv) {
                        currentBotMessageContentDiv.innerHTML += `<p>Error: ${error.message}</p>`;
                    } else {
                        addMessage(`Sorry, there was an error processing your request: ${error.message}. Please try again.`, 'bot', null, new Date());
                    }
                }
                finalizeStreamingBotMessage(); // Attempt to finalize even on error
            } finally {
                textInput.value = ''; 
                textInput.style.height = 'auto'; // Reset textarea height
                textInput.focus();
                showSendButton(); // Show send button, hide stop button
                abortController = null; // Clear the controller
            }
        }

        async function generateImage(prompt) {
            const textInput = document.getElementById('text-input');
            const loader = document.getElementById('loader');
            loader.style.display = 'block'; 
            showStopButton(); // Show stop button
            stopSpeaking(); // Stop AI speech if any

            abortController = new AbortController();
            const signal = abortController.signal;
            
            try {
                const formData = new FormData();
                formData.append('instruction', prompt); 
                formData.append('chat_id', currentChatId); 

                const response = await fetch(`${window.location.origin}/generate_image`, { 
                    method: 'POST',
                    body: formData,
                    signal: signal // Pass the abort signal
                });
                const data = await response.json();

                loader.style.display = 'none';

                if (data.image_urls && data.image_urls.length > 0) {
                    addMessage(data.response, 'bot', data.image_urls, new Date()); 
                    if (isVoiceTalkActive && data.response) speakText(data.response);
                } else {
                    addMessage(data.response, 'bot', null, new Date());
                    if (isVoiceTalkActive && data.response) speakText(data.response);
                }
            } catch (error) {
                loader.style.display = 'none'; // Hide loader on error
                if (error.name === 'AbortError') {
                    console.log('Image generation aborted by user.');
                    addMessage(`Image generation stopped by user.`, 'bot', null, new Date());
                } else {
                    addMessage(`Sorry, there was an error generating the image: ${error.message}. Please try again.`, 'bot', null, new Date());
                }
            } finally {
                textInput.value = '';
                textInput.style.height = 'auto'; 
                textInput.focus();
                showSendButton(); // Show send button
                abortController = null;
                if (isVoiceTalkActive) startListening(); // Restart listening after AI finishes
            }
        }

        async function uploadImage(file, caption) {
            const loader = document.getElementById('loader');
            loader.style.display = 'block'; // Show loader for upload
            showStopButton(); // Show stop button
            stopSpeaking(); // Stop AI speech if any

            abortController = new AbortController();
            const signal = abortController.signal;

            try {
                const formData = new FormData();
                formData.append('image', file);
                if (caption) {
                    formData.append('caption', caption);
                }
                formData.append('chat_id', currentChatId); 

                const response = await fetch(`${window.location.origin}/upload_image`, {
                    method: 'POST',
                    body: formData,
                    signal: signal // Pass the abort signal
                });
                const data = await response.json(); 
                
                loader.style.display = 'none'; // Hide loader after response
                if (data && data.response) {
                    // Assuming the backend has already saved the user's message (caption + image) correctly.
                    // Now, display the AI's response (which might contain extracted text) as a separate bot message.
                    if (data.image_urls && data.image_urls.length > 0) {
                        addMessage(data.response, 'bot', data.image_urls, new Date());
                        if (isVoiceTalkActive && data.response) speakText(data.response);
                    } else {
                        addMessage(data.response, 'bot', null, new Date());
                        if (isVoiceTalkActive && data.response) speakText(data.response);
                    }
                } else {
                    console.error("Image upload failed: Received an empty response or no AI response."); 
                    addMessage("Received an empty response from the server after image upload. Please try again.", 'bot', null, new Date());
                }
            } catch (error) {
                loader.style.display = 'none'; // Hide loader on error
                if (error.name === 'AbortError') {
                    console.log('Image upload aborted by user.');
                    addMessage(`Image upload stopped by user.`, 'bot', null, new Date());
                } else {
                    addMessage(`Failed to upload image due to network error: ${error.message}. Please try again.`, 'bot', null, new Date());
                }
            } finally {
                clearImagePreview(); // Clear preview in all cases
                showSendButton(); // Show send button
                abortController = null;
                if (isVoiceTalkActive) startListening(); // Restart listening after AI finishes
            }
        }

        // --- UPDATED: Web Search Functionality to use a backend proxy ---
        async function performWebSearch(query) {
            const textInput = document.getElementById('text-input');
            const loader = document.getElementById('loader');
            loader.style.display = 'block'; 
            showStopButton(); // Show stop button
            stopSpeaking(); // Stop AI speech if any

            abortController = new AbortController();
            const signal = abortController.signal;

            // IMPORTANT: For production, you MUST proxy Serper API requests through your backend
            // to keep your API key secure and avoid CORS issues.
            // This frontend code assumes you have a backend endpoint like '/web_search'
            // that handles the actual call to Serper.dev with your API key.
            const BACKEND_WEB_SEARCH_ENDPOINT = `${window.location.origin}/web_search`; 

            try {
                const response = await fetch(BACKEND_WEB_SEARCH_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ q: query, chat_id: currentChatId }),
                    signal: signal // Pass the abort signal
                });

                if (!response.ok) {
                    let errorMessage = `Web search failed with status ${response.status}`;

                    try {
                        const cloned = response.clone(); // Clone the stream
                        const errorData = await cloned.json();
                        if (errorData?.error) {
                            errorMessage = `Web search failed: ${errorData.error}`;
                        }
                    } catch (e) {
                        try {
                            const fallbackCloned = response.clone(); // Clone again to read text
                            const text = await fallbackCloned.text();
                            if (text && text.startsWith('<')) {
                                errorMessage = "Server returned an HTML error page. Check if your backend route returns JSON.";
                            } else {
                                errorMessage = `Unexpected error response: ${text}`;
                            }
                        } catch (finalError) {
                            errorMessage = `Could not read error body: ${finalError.message}`;
                        }
                    }

                    throw new Error(errorMessage);
                }

                const data = await response.json();
                loader.style.display = 'none';

                let botResponseText = `Here are some web search results for "${query}":\n\n`;
                let hasResults = false;

                if (data.answerBox && data.answerBox.snippet) {
                    botResponseText += `**Answer:** ${data.answerBox.snippet}\n\n`;
                    hasResults = true;
                } else if (data.knowledgeGraph && data.knowledgeGraph.snippet) {
                    botResponseText += `**Knowledge:** ${data.knowledgeGraph.snippet}\n\n`;
                    hasResults = true;
                }

                if (data.organic && data.organic.length > 0) {
                    botResponseText += "**Top Results:**\n";
                    data.organic.slice(0, 5).forEach((result, index) => { // Limit to top 5 results
                        botResponseText += `${index + 1}. [${result.title}](${result.link})\n`;
                        if (result.snippet) {
                            botResponseText += `   ${result.snippet}\n`;
                        }
                        botResponseText += '\n';
                    });
                    hasResults = true;
                }

                if (!hasResults) {
                    botResponseText = `No significant web search results found for "${query}".`;
                }
                
                addMessage(botResponseText, 'bot', null, new Date()); // Use addMessage for non-streaming
                if (isVoiceTalkActive && botResponseText) speakText(botResponseText);

            } catch (error) {
                loader.style.display = 'none'; // Hide loader on error
                if (error.name === 'AbortError') {
                    console.log('Web search aborted by user.');
                    addMessage(`Web search stopped by user.`, 'bot', null, new Date());
                } else {
                    addMessage(`Sorry, there was an error performing the web search: ${error.message}. Please try again.`, 'bot', null, new Date());
                }
            } finally {
                textInput.value = '';
                textInput.style.height = 'auto';
                textInput.focus();
                showSendButton(); // Show send button
                abortController = null;
                if (isVoiceTalkActive) startListening(); // Restart listening after AI finishes
            }
        }
        // --- END UPDATED: Web Search Functionality ---

        async function summarizeText(textToSummarize) {
            try {
                const response = await fetch(`${window.location.origin}/summarize_text`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ text: textToSummarize, chat_id: currentChatId }), 
                });
                const data = await response.json();
                if (data && data.summary) {
                    return data.summary;
                } else {
                    console.error("Summarization failed:", data.error || "No summary returned.");
                    return null;
                }
            } catch (error) {
                console.error("Error summarizing text:", error);
                return null;
            }
        }

        async function checkGrammarAndStyle(text) {
            const textInput = document.getElementById('text-input');
            const loader = document.getElementById('loader');
            loader.style.display = 'block';
            showStopButton(); // Show stop button
            stopSpeaking(); // Stop AI speech if any

            abortController = new AbortController();
            const signal = abortController.signal;

            try {
                const formData = new FormData();
                formData.append('text', text);
                formData.append('chat_id', currentChatId);

                const response = await fetch(`${window.location.origin}/check_grammar_style`, {
                    method: 'POST',
                    body: formData,
                    signal: signal // Pass the abort signal
                });
                const data = await response.json();
                loader.style.display = 'none';
                if (data && data.corrected_text) {
                    addMessage(data.corrected_text, 'bot', null, new Date());
                    if (isVoiceTalkActive && data.corrected_text) speakText(data.corrected_text);
                } else {
                    console.error("Grammar/Style check failed:", data.error || "No response returned.");
                    addMessage(data.error || "Failed to check grammar and style.", 'bot', null, new Date());
                }
            } catch (error) {
                loader.style.display = 'none'; // Hide loader on error
                if (error.name === 'AbortError') {
                    console.log('Grammar check aborted by user.');
                    addMessage(`Grammar check stopped by user.`, 'bot', null, new Date());
                } else {
                    addMessage(`Sorry, an error occurred while checking the grammar and style: ${error.message}. Please try again.`, 'bot', null, new Date());
                }
            } finally {
                textInput.value = '';
                textInput.style.height = 'auto';
                textInput.focus();
                showSendButton(); // Show send button
                abortController = null;
                if (isVoiceTalkActive) startListening(); // Restart listening after AI finishes
            }
        }

        async function explainCode(code) {
            const textInput = document.getElementById('text-input');
            const loader = document.getElementById('loader');
            loader.style.display = 'block';
            showStopButton(); // Show stop button
            stopSpeaking(); // Stop AI speech if any

            abortController = new AbortController();
            const signal = abortController.signal;

            try {
                const formData = new FormData();
                formData.append('code', code);
                formData.append('chat_id', currentChatId);

                const response = await fetch(`${window.location.origin}/explain_code`, {
                    method: 'POST',
                    body: formData,
                    signal: signal // Pass the abort signal
                });
                const data = await response.json();
                loader.style.display = 'none';
                if (data && data.explanation) {
                    addMessage(data.explanation, 'bot', null, new Date());
                    if (isVoiceTalkActive && data.explanation) speakText(data.explanation);
                } else {
                    console.error("Code explanation failed:", data.error || "No response returned.");
                    addMessage(data.error || "Failed to explain code.", 'bot', null, new Date());
                }
            } catch (error) {
                loader.style.display = 'none'; // Hide loader on error
                if (error.name === 'AbortError') {
                    console.log('Code explanation aborted by user.');
                    addMessage(`Code explanation stopped by user.`, 'bot', null, new Date());
                } else {
                    addMessage(`Sorry, an error occurred while explaining the code: ${error.message}. Please try again.`, 'bot', null, new Date());
                }
            } finally {
                textInput.value = '';
                textInput.style.height = 'auto';
                textInput.focus();
                showSendButton(); // Show send button
                abortController = null;
                if (isVoiceTalkActive) startListening(); // Restart listening after AI finishes
            }
        }

        // UI Functions
        function showModal() {
            document.getElementById('confirmModal').style.display = 'flex';
        }

        function hideModal() {
            document.getElementById('confirmModal').style.display = 'none';
        }
        
        // Show image preview in the input area
        function showImagePreview(file) {
            const imagePreviewContainer = document.getElementById('image-preview-container');
            const imagePreview = document.getElementById('image-preview');
            const clearImageBtn = document.getElementById('clear-image-btn');

            const reader = new FileReader();
            reader.onload = function(e) {
                imagePreview.src = e.target.result;
                imagePreview.style.display = 'block';
                imagePreviewContainer.style.display = 'flex';
                clearImageBtn.style.display = 'flex';
            };
            reader.readAsDataURL(file);
        }

        // Clear image preview from the input area
        function clearImagePreview() {
            const imagePreviewContainer = document.getElementById('image-preview-container');
            const imagePreview = document.getElementById('image-preview');
            const clearImageBtn = document.getElementById('clear-image-btn');
            const takePhotoInput = document.getElementById('take-photo-input'); // Get new inputs
            const uploadPhotoInput = document.getElementById('upload-photo-input');

            imagePreview.src = '#';
            imagePreview.style.display = 'none';
            imagePreviewContainer.style.display = 'none';
            clearImageBtn.style.display = 'none';
            if (takePhotoInput) takePhotoInput.value = ''; // Clear file inputs
            if (uploadPhotoInput) uploadPhotoInput.value = '';
        }

        // Toggle full screen mode
        window.toggleFullScreen = function() {
            const body = document.body;
            isFullScreen = !isFullScreen;
            
            if (isFullScreen) {
                body.classList.add('full-screen-mode');
            } else {
                body.classList.remove('full-screen-mode');
                // Restore sidebar visibility based on previous state if on desktop
                if (window.innerWidth > 768 && !sidebarHidden) {
                    document.getElementById('sidebar').classList.remove('collapsed');
                    document.querySelector('.main').classList.remove('full-width');
                }
            }
            // Ensure the correct sidebar toggle button is shown/hidden after full screen toggle
            updateSidebarToggleButtonVisibility();
        };

        window.clearAllChats = function() {
            showModal();
        };

        window.startNewChat = async function(isInitialLoad = false) {
            const chatbox = document.getElementById('chatbox');
            const textInput = document.getElementById('text-input');
            const modelGeneralRadio = document.getElementById('modelGeneral'); // Get radio button

            try {
                const response = await fetch(`${window.location.origin}/start_new_chat`, { method: 'POST' });
                const data = await response.json();
                if (data.chat_id) {
                    currentChatId = data.chat_id;
                    chatbox.innerHTML = '';
                    textInput.value = '';
                    textInput.style.height = 'auto';
                    textInput.focus();
                    textInput.setAttribute('required', '');
                    textInput.placeholder = 'Send a message, \'generate image of a car\', or type \'explain code\', \'grammar check\' etc.'; // Updated placeholder for new chat
                    clearImagePreview(); // Clear any existing image preview
                    modelGeneralRadio.checked = true; // Set General Talk as default on new chat
                    
                    if (!isInitialLoad || (isInitialLoad && !data.has_previous_chats)) {
                         addMessage("New chat started. How can I assist you today?", 'bot', null, new Date()); 
                    }
                   
                    await updateChatHistory();
                } else {
                    console.error("Failed to get a new chat ID from backend.");
                    addMessage("Failed to start new chat. Please try refreshing the page.", 'bot', null, new Date());
                }
            } catch (error) {
                console.error("Error starting new chat:", error);
                addMessage("Failed to start new chat due to network error. Please try again.", 'bot', null, new Date());
            }
        };

        window.toggleDarkMode = function() {
            document.body.classList.toggle('dark-mode');
            if (document.body.classList.contains('dark-mode')) {
                localStorage.setItem('darkMode', 'enabled');
            } else {
                localStorage.removeItem('darkMode');
            }
        };

        // Handles sidebar visibility for both desktop collapse and mobile slide-out
        window.toggleSidebar = function() {
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.querySelector('.main');
            
            if (window.innerWidth <= 768 || isFullScreen) { // Mobile or Full Screen mode
                sidebar.classList.toggle('visible');
            } else { // Desktop
                sidebar.classList.toggle('collapsed');
                mainContent.classList.toggle('full-width');
                sidebarHidden = sidebar.classList.contains('collapsed'); // Update hidden state
            }
            updateSidebarToggleButtonVisibility(); // Update button visibility after toggling
        };

        // Helper function to manage sidebar toggle button visibility
        function updateSidebarToggleButtonVisibility() {
            const sidebar = document.getElementById('sidebar');
            const showSidebarBtn = document.getElementById('showSidebarBtn');
            const sidebarToggleButton = document.getElementById('sidebarToggleButton'); // The button inside the sidebar

            if (window.innerWidth <= 768 || isFullScreen) { // Mobile or Full Screen mode
                if (sidebar.classList.contains('visible')) {
                    showSidebarBtn.style.display = 'none';
                    sidebarToggleButton.style.display = 'block';
                    sidebarToggleButton.querySelector('i').className = 'fas fa-times'; // 'X' icon for close
                } else {
                    showSidebarBtn.style.display = 'flex';
                    sidebarToggleButton.style.display = 'none';
                    showSidebarBtn.querySelector('i').className = 'fas fa-bars'; // 'Bars' icon for open
                }
            } else { // Desktop
                if (sidebar.classList.contains('collapsed')) {
                    showSidebarBtn.style.display = 'flex'; // Show floating button to expand
                    sidebarToggleButton.style.display = 'none'; // Hide internal toggle
                    showSidebarBtn.querySelector('i').className = 'fas fa-bars'; // 'Bars' icon for open
                } else {
                    showSidebarBtn.style.display = 'none'; // Hide floating button
                    sidebarToggleButton.style.display = 'block'; // Show internal toggle
                    sidebarToggleButton.querySelector('i').className = 'fas fa-times'; // 'X' icon for close
                }
            }
        }

        // Functions to toggle visibility of Send and Stop buttons
        function showSendButton() {
            if (isVoiceTalkActive) return; // Do not show if voice talk is active
            document.getElementById('send-btn').style.display = 'flex';
            document.getElementById('stop-btn').style.display = 'none';
        }

        function showStopButton() {
            if (isVoiceTalkActive) return; // Do not show if voice talk is active
            document.getElementById('send-btn').style.display = 'none';
            document.getElementById('stop-btn').style.display = 'flex';
        }

        // Voice Talk Functions
        const voiceTalkBtn = document.getElementById('voice-talk-btn');
        const micIcon = voiceTalkBtn.querySelector('i');
        const voiceModeOverlay = document.getElementById('voice-mode-overlay');
        const mainContentElement = document.querySelector('.main'); // Renamed to avoid conflict with local variable
        const micControlBtn = document.getElementById('mic-control-btn');
        const closeVoiceModeBtn = document.getElementById('close-voice-mode-btn');
        const voiceStatusTextOverlay = voiceModeOverlay.querySelector('.status-text');
        const screenShareBtn = document.getElementById('screen-share-btn'); // New screen share button

        function initializeSpeechRecognition() {
            if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
                recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                recognition.continuous = false; // Only listen for a single utterance
                recognition.interimResults = false; // Only return final results
                recognition.lang = 'en-US'; // Set language

                recognition.onstart = () => {
                    isListening = true;
                    micControlBtn.classList.add('mic-active');
                    micControlBtn.querySelector('i').className = 'fas fa-microphone-alt'; // Listening icon
                    voiceStatusTextOverlay.textContent = 'Listening...';
                    console.log('Speech recognition started.');
                    stopSpeaking(); // Stop AI speech if user starts talking
                    startVoiceVisualizer(false); // Start visualizer for user input
                };

                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    document.getElementById('text-input').value = transcript;
                    console.log('Speech recognized:', transcript);
                    // Automatically submit the form after speech is recognized
                    document.getElementById('multi-action-form').dispatchEvent(new Event('submit', { cancelable: true }));
                };

                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    micControlBtn.classList.remove('mic-active');
                    micControlBtn.querySelector('i').className = 'fas fa-microphone'; // Default icon on error
                    isListening = false;
                    stopVoiceVisualizer(); // Stop visualizer on error
                    if (isVoiceTalkActive && !isSpeaking) {
                        voiceStatusTextOverlay.textContent = 'Error: ' + event.error + '. Tap mic to retry.';
                        // Do NOT automatically restart here, let user tap again
                    }
                };

                recognition.onend = () => {
                    console.log('Speech recognition ended.');
                    isListening = false;
                    micControlBtn.classList.remove('mic-active');
                    micControlBtn.querySelector('i').className = 'fas fa-microphone'; // Default icon
                    stopVoiceVisualizer(); // Stop visualizer when listening ends
                    if (isVoiceTalkActive && !isSpeaking) {
                        voiceStatusTextOverlay.textContent = 'Standard voice'; // Reset status text
                        // Only restart listening if AI is not speaking and voice mode is still active
                        // This will be handled by finalizeStreamingBotMessage or micControlBtn click
                    } else if (!isVoiceTalkActive) {
                        voiceStatusTextOverlay.textContent = 'Standard voice';
                    }
                };
            } else {
                voiceTalkBtn.disabled = true;
                voiceTalkBtn.title = "Voice talk not supported in your browser.";
                console.warn("Web Speech API not supported in this browser.");
                // Provide user feedback directly in chat if it's the first time they try
                addMessage("Your browser does not support Web Speech Recognition. Please use a compatible browser like Chrome or Edge.", 'bot', null, new Date());
            }
        }

        function startListening() {
            if (recognition && isVoiceTalkActive && !isListening && !isSpeaking) { // Ensure not speaking
                try {
                    recognition.start();
                } catch (e) {
                    console.warn("Recognition already started or other error:", e);
                    if (e.message.includes('already started')) {
                        // Ignore if already started, but log for debugging
                    } else if (e.message.includes('permission denied')) {
                        voiceStatusTextOverlay.textContent = 'Microphone permission denied. Please allow access.';
                        addMessage("Microphone access denied. Please enable microphone permissions for this site in your browser settings to use voice features.", 'bot', null, new Date());
                    } else {
                        voiceStatusTextOverlay.textContent = 'Error starting mic. Tap to retry.';
                        addMessage("An error occurred trying to start the microphone: " + e.message, 'bot', null, new Date());
                    }
                }
            } else if (!recognition) {
                voiceStatusTextOverlay.textContent = 'Speech API not available.';
                addMessage("Web Speech API is not available in your browser.", 'bot', null, new Date());
            }
        }

        function stopListening() {
            if (recognition && isListening) {
                recognition.stop();
            }
        }

        // Function to set the AI's voice
        function setAIVoice() {
            const voices = synth.getVoices();
            // Try to find a specific voice, e.g., a female voice, or one with a clear, standard accent.
            // You might need to inspect `voices` array in your browser's console to find suitable names.
            // Common names: 'Google US English', 'Microsoft Zira - English (United States)', 'Samantha' (iOS)
            selectedVoice = voices.find(voice => voice.name.includes('Google US English') && voice.lang === 'en-US' && voice.gender === 'female') ||
                            voices.find(voice => voice.name.includes('Zira') && voice.lang === 'en-US') ||
                            voices.find(voice => voice.lang === 'en-US' && voice.name.includes('Female')) ||
                            voices.find(voice => voice.lang === 'en-US') ||
                            voices[0]; // Fallback to the first available voice

            if (selectedVoice) {
                console.log("AI Voice selected:", selectedVoice.name, selectedVoice.lang);
            } else {
                console.warn("Could not find a specific AI voice, using default.");
            }
        }

        function speakText(text) {
            if (!isVoiceTalkActive || !synth || !selectedVoice) {
                console.warn("Speech synthesis not active, synth not available, or no voice selected. Cannot speak.");
                return;
            }

            speechQueue.push(text); // Add text to the queue
            processSpeechQueue(); // Start/continue processing the queue
        }

        function processSpeechQueue() {
            if (isProcessingSpeechQueue || speechQueue.length === 0) {
                return; // Already processing or nothing to speak
            }

            isProcessingSpeechQueue = true;
            stopListening(); // Stop listening while AI is speaking

            const textToSpeak = speechQueue.shift(); // Get the next text from the queue
            const utterance = new SpeechSynthesisUtterance(textToSpeak);
            utterance.lang = 'en-US';
            utterance.pitch = 1.0; // Default pitch (0.1 to 2.0)
            utterance.rate = 1.0; // Default rate (0.1 to 10.0)
            utterance.voice = selectedVoice; // Apply the selected voice

            utterance.onstart = () => {
                isSpeaking = true;
                micControlBtn.classList.add('mic-active');
                micControlBtn.querySelector('i').className = 'fas fa-volume-up'; // Speaking icon
                voiceStatusTextOverlay.textContent = 'Speaking...';
                console.log('Speech synthesis started.');
                startVoiceVisualizer(true); // Start visualizer for AI speech
            };

            utterance.onend = () => {
                console.log('Speech synthesis ended.');
                isSpeaking = false;
                stopVoiceVisualizer(); // Stop visualizer
                isProcessingSpeechQueue = false; // Mark as done with current utterance

                if (speechQueue.length > 0) {
                    processSpeechQueue(); // Process next in queue
                } else {
                    // Only reset controls and restart listening if the entire queue is empty
                    micControlBtn.classList.remove('mic-active');
                    micControlBtn.querySelector('i').className = 'fas fa-microphone'; // Default icon
                    if (isVoiceTalkActive) {
                        voiceStatusTextOverlay.textContent = 'Standard voice'; // Reset status text
                        startListening(); // Restart listening after AI finishes speaking
                    }
                }
            };

            utterance.onerror = (event) => {
                console.error('Speech synthesis error:', event.error);
                isSpeaking = false;
                stopVoiceVisualizer(); // Stop visualizer
                isProcessingSpeechQueue = false; // Mark as done with current utterance

                // Clear the rest of the queue on error to prevent cascading issues
                speechQueue = []; 

                micControlBtn.classList.remove('mic-active');
                micControlBtn.querySelector('i').className = 'fas fa-microphone'; // Default icon on error
                if (isVoiceTalkActive) {
                    voiceStatusTextOverlay.textContent = 'Speech error. Tap mic to retry.'; // More informative error
                    startListening(); // Try to restart listening
                }
            };

            synth.speak(utterance);
        }

        function stopSpeaking() {
            if (isSpeaking || isProcessingSpeechQueue) {
                synth.cancel(); // Stops current utterance
                speechQueue = []; // Clear any pending utterances
                isSpeaking = false;
                isProcessingSpeechQueue = false;
                micControlBtn.classList.remove('mic-active');
                micControlBtn.querySelector('i').className = 'fas fa-microphone'; // Default icon
                stopVoiceVisualizer(); // Stop visualizer
            }
        }

        // Web Audio API Visualizer Logic
        async function initializeVoiceVisualizer() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                console.warn("getUserMedia not supported in this browser.");
                return;
            }

            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048; // Fast Fourier Transform size
                bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength); // Array to hold frequency data

                canvas = document.getElementById('voice-circle-canvas');
                canvasCtx = canvas.getContext('2d');

                // Set canvas dimensions dynamically
                const setCanvasSize = () => {
                    const size = Math.min(window.innerWidth, window.innerHeight) * 0.5; // Max 50% of smaller dimension
                    canvas.width = size;
                    canvas.height = size;
                    canvasCtx.clearRect(0, 0, canvas.width, canvas.height); // Clear after resize
                };
                setCanvasSize();
                window.addEventListener('resize', setCanvasSize);

                // Get microphone stream only once
                if (!microphoneStream) {
                    microphoneStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const source = audioContext.createMediaStreamSource(microphoneStream);
                    source.connect(analyser);
                    // analyser.connect(audioContext.destination); // Connect to speakers for monitoring, optional
                }

                // Connect AI voice to analyser (if available and needed for AI voice visualization)
                // This part is tricky as SpeechSynthesis does not directly expose an audio source node.
                // For a true AI voice visualizer, you'd need a more advanced setup like a Web Audio API
                // implementation that generates the speech, or a browser that exposes the output.
                // For now, the visualizer will react to microphone input AND will be triggered when AI speaks.
                // The AI voice "pitch" reactivity will be simulated based on the speaking state.
                
            } catch (err) {
                console.error("Error accessing microphone for visualizer:", err);
                // Disable voice features if mic access fails
                voiceTalkBtn.disabled = true;
                voiceTalkBtn.title = "Microphone access denied or not available.";
                micControlBtn.disabled = true;
                micControlBtn.title = "Microphone access denied or not available.";
                addMessage("Microphone access is required for voice visualization and input. Please enable it in your browser settings.", 'bot', null, new Date());
            }
        }

        function startVoiceVisualizer(isAIVoice = false) {
            if (!analyser || !canvasCtx) return;

            cancelAnimationFrame(animationFrameId); // Stop any existing animation
            
            const draw = () => {
                animationFrameId = requestAnimationFrame(draw);

                analyser.getByteFrequencyData(dataArray); // Get frequency data

                canvasCtx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const maxRadius = Math.min(centerX, centerY) * 0.7; // Max size

                // Calculate overall volume (amplitude)
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i];
                }
                let average = sum / bufferLength;
                let normalizedVolume = average / 128; // Normalize to 0-2 range (can exceed 1 for loud sounds)
                normalizedVolume = Math.min(2, Math.max(0, normalizedVolume)); // Clamp between 0 and 2

                const baseCircleRadius = Math.min(centerX, centerY) * 0.4;
                const maxCircleExpansion = Math.min(centerX, centerY) * 0.3; // Max expansion beyond base

                // Dynamic properties based on AI voice or user voice
                const mainColor = isAIVoice ? '106, 13, 173' : '16, 163, 127'; // Accent vs Primary
                const numRings = isAIVoice ? 7 : 5; // More rings for AI
                const baseLineWidth = isAIVoice ? 3 : 2; // Thicker lines for AI
                const maxLineWidthBoost = isAIVoice ? 7 : 5; // More boost for AI

                // Add a subtle rotation for AI voice
                if (isAIVoice) {
                    canvasCtx.save();
                    canvasCtx.translate(centerX, centerY);
                    canvasCtx.rotate(Date.now() * 0.0005 % (2 * Math.PI)); // Slow continuous rotation
                    canvasCtx.translate(-centerX, -centerY);
                }

                for (let i = 0; i < numRings; i++) {
                    const ringOffset = i * (maxCircleExpansion / numRings);
                    let currentRadius = baseCircleRadius + (normalizedVolume * maxCircleExpansion * 0.5) + ringOffset;
                    
                    // More dynamic animation for AI voice
                    const animationFactor = isAIVoice ? Math.sin(Date.now() * 0.008 + i * 0.7) * 0.07 : Math.sin(Date.now() * 0.005 + i * 0.5) * 0.05;
                    currentRadius *= (1 + animationFactor);

                    const opacity = 0.1 + (normalizedVolume * 0.4) * (1 - (i / numRings));
                    const lineWidth = baseLineWidth + (normalizedVolume * maxLineWidthBoost) * (1 - (i / numRings));

                    canvasCtx.beginPath();
                    canvasCtx.arc(centerX, centerY, currentRadius, 0, 2 * Math.PI);
                    canvasCtx.strokeStyle = `rgba(${mainColor}, ${opacity})`;
                    canvasCtx.lineWidth = lineWidth;
                    canvasCtx.stroke();
                }

                // Draw a central solid circle that pulses more
                const centralRadius = baseCircleRadius * 0.8 + (normalizedVolume * baseCircleRadius * 0.2);
                canvasCtx.beginPath();
                canvasCtx.arc(centerX, centerY, centralRadius, 0, 2 * Math.PI);
                canvasCtx.fillStyle = `rgba(${mainColor}, ${0.5 + normalizedVolume * 0.4})`; // More opaque for AI
                canvasCtx.fill();

                if (isAIVoice) {
                    canvasCtx.restore(); // Restore canvas state after rotation
                }
            };
            draw();
        }

        function stopVoiceVisualizer() {
            cancelAnimationFrame(animationFrameId);
            if (canvasCtx) {
                canvasCtx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
            }
        }

        voiceTalkBtn.addEventListener('click', () => {
            isVoiceTalkActive = !isVoiceTalkActive;
            
            if (isVoiceTalkActive) {
                console.log("Voice Talk ON");
                voiceModeOverlay.classList.add('active'); // Show full-screen overlay
                mainContentElement.style.display = 'none'; // Hide main chat UI
                voiceStatusTextOverlay.textContent = 'Standard voice'; // Initial status for overlay
                startListening(); // Attempt to start listening
            } else {
                console.log("Voice Talk OFF");
                stopListening();
                stopSpeaking(); // Ensure all speech and visualizer are stopped
                stopVoiceVisualizer(); // Stop visualizer when exiting voice mode
                stopScreenShare(); // Stop screen share if active

                voiceModeOverlay.classList.remove('active'); // Hide full-screen overlay
                mainContentElement.style.display = 'flex'; // Show main chat UI

                micControlBtn.classList.remove('mic-active'); // Reset mic button on overlay
                micControlBtn.querySelector('i').className = 'fas fa-microphone';
            }
        });

        // Event listener for the mic button on the overlay
        micControlBtn.addEventListener('click', () => {
            if (isListening) {
                stopListening();
                voiceStatusTextOverlay.textContent = 'Tap mic to speak.'; // Prompt user to tap again
            } else {
                startListening();
            }
        });

        // Event listener for the close button on the overlay
        closeVoiceModeBtn.addEventListener('click', () => {
            isVoiceTalkActive = false; // Deactivate voice mode
            // Manually trigger the state change that voiceTalkBtn.click() would do
            stopListening();
            stopSpeaking();
            stopVoiceVisualizer();
            stopScreenShare(); // Stop screen share if active

            voiceModeOverlay.classList.remove('active');
            mainContentElement.style.display = 'flex';
            micControlBtn.classList.remove('mic-active');
            micControlBtn.querySelector('i').className = 'fas fa-microphone';
            showSendButton(); // Ensure send button is visible if not in voice mode
        });

        // NEW: Screen Share Functions
        screenShareBtn.addEventListener('click', () => {
            if (isScreenSharing) {
                stopScreenShare();
            } else {
                startScreenShare();
            }
        });

        async function startScreenShare() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
                addMessage("Screen sharing not supported in your browser.", 'bot', null, new Date());
                if (isVoiceTalkActive) speakText("Screen sharing not supported in your browser.");
                console.warn("getDisplayMedia not supported.");
                return;
            }

            try {
                // Request screen share stream
                screenShareStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
                screenShareVideoElement.srcObject = screenShareStream;
                screenSharePreviewContainer.style.display = 'flex'; // Show preview

                isScreenSharing = true;
                screenShareBtn.classList.add('screen-share-active');
                screenShareBtn.querySelector('i').className = 'fas fa-stop-circle'; // Stop icon

                // Listen for when the user stops sharing directly from the browser's UI
                screenShareStream.getVideoTracks()[0].onended = () => {
                    console.log("Screen share ended by user.");
                    stopScreenShare();
                };

                // Start capturing and sending frames
                screenShareInterval = setInterval(captureAndSendScreenFrame, 2000); // Send frame every 2 seconds
                addMessage("Screen sharing started. I will analyze your screen for issues.", 'bot', null, new Date());
                if (isVoiceTalkActive) speakText("Screen sharing started. I will analyze your screen for issues.");

            } catch (err) {
                console.error("Error starting screen share:", err);
                addMessage("Could not start screen sharing. Please ensure you grant permission.", 'bot', null, new Date());
                if (isVoiceTalkActive) speakText("Could not start screen sharing. Please ensure you grant permission.");
                isScreenSharing = false;
                screenShareBtn.classList.remove('screen-share-active');
                screenShareBtn.querySelector('i').className = 'fas fa-desktop';
                screenSharePreviewContainer.style.display = 'none';
            }
        }

        function stopScreenShare() {
            if (screenShareStream) {
                screenShareStream.getTracks().forEach(track => track.stop());
                screenShareStream = null;
            }
            if (screenShareInterval) {
                clearInterval(screenShareInterval);
                screenShareInterval = null;
            }
            isScreenSharing = false;
            screenShareBtn.classList.remove('screen-share-active');
            screenShareBtn.querySelector('i').className = 'fas fa-desktop'; // Reset icon
            screenSharePreviewContainer.style.display = 'none'; // Hide preview
            addMessage("Screen sharing stopped.", 'bot', null, new Date());
            if (isVoiceTalkActive) speakText("Screen sharing stopped.");
        }

        async function captureAndSendScreenFrame() {
            if (!screenShareVideoElement || !isScreenSharing) return;

            // Set canvas dimensions to match video stream
            screenCaptureCanvas.width = screenShareVideoElement.videoWidth;
            screenCaptureCanvas.height = screenShareVideoElement.videoHeight;
            
            // Draw the current video frame onto the canvas
            screenCaptureCtx.drawImage(screenShareVideoElement, 0, 0, screenCaptureCanvas.width, screenCaptureCanvas.height);

            // Get base64 image data from the canvas
            const imageDataUrl = screenCaptureCanvas.toDataURL('image/jpeg', 0.7); // JPEG for compression, 70% quality
            const base64Image = imageDataUrl.split(',')[1]; // Remove "data:image/jpeg;base64," prefix

            try {
                const formData = new FormData();
                formData.append('image', base64Image);
                formData.append('chat_id', currentChatId);
                formData.append('instruction', 'Analyze this screenshot for any UI/code issues, errors, or areas for improvement. Suggest specific fixes or next steps, including code if applicable.');

                const response = await fetch(`${window.location.origin}/process_screen_frame`, {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                if (data && data.response) {
                    addMessage(`**Screen Analysis:** ${data.response}`, 'bot', null, new Date());
                    if (isVoiceTalkActive) speakText(data.response);
                } else {
                    console.error("Screen analysis failed: No response from AI.");
                }
            } catch (error) {
                console.error("Error sending screen frame to AI:", error);
                // Optionally add a message to the chat about the error
            }
        }

        // NEW: Code Update Modal Functions
        const codeUpdateModal = document.getElementById('codeUpdateModal');
        const fileToUpdateSelect = document.getElementById('fileToUpdateSelect');
        const codeUpdateTextarea = document.getElementById('codeUpdateTextarea');
        const applyCodeUpdateBtn = document.getElementById('applyCodeUpdateBtn');

        window.openCodeUpdateModal = function(suggestedCode = '', fileType = 'html') {
            codeUpdateTextarea.value = suggestedCode;
            // Set the selected file type in the dropdown
            if (fileToUpdateSelect) {
                const options = Array.from(fileToUpdateSelect.options);
                const matchingOption = options.find(option => option.value.includes(fileType));
                if (matchingOption) {
                    fileToUpdateSelect.value = matchingOption.value;
                } else {
                    fileToUpdateSelect.value = 'index.html'; // Default
                }
            }
            codeUpdateModal.style.display = 'flex';
        };

        applyCodeUpdateBtn.addEventListener('click', async () => {
            const fileName = fileToUpdateSelect.value;
            const fileContent = codeUpdateTextarea.value;

            if (!fileName || !fileContent) {
                addMessage("Please select a file and provide content to update.", 'bot', null, new Date());
                return;
            }

            addMessage(`Attempting to update ${fileName}...`, 'user', null, new Date());
            codeUpdateModal.style.display = 'none'; // Hide modal immediately

            try {
                const formData = new FormData();
                formData.append('file_name', fileName);
                formData.append('file_content', fileContent);

                const response = await fetch(`${window.location.origin}/update_file`, {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                if (data.status === 'success') {
                    addMessage(`Successfully updated ${fileName}: ${data.message}`, 'bot', null, new Date());
                } else {
                    addMessage(`Failed to update ${fileName}: ${data.message}`, 'bot', null, new Date());
                }
            } catch (error) {
                console.error("Error applying code update:", error);
                addMessage(`Error communicating with server for file update: ${error.message}`, 'bot', null, new Date());
            }
        });


        async function updateChatHistory() {
            const chatHistoryList = document.getElementById('chat-history-list');
            chatHistoryList.innerHTML = ''; // Clear existing history
            try {
                const response = await fetch(`${window.location.origin}/get_chat_history_list`);
                const chatSummaries = await response.json(); 

                if (chatSummaries.length === 0) {
                    await startNewChat(true); // Start a new chat if no history
                } else {
                    chatSummaries.forEach(chatSummary => {
                        const chatLink = document.createElement('a');
                        chatLink.href = "#";
                        chatLink.className = `chat-link ${chatSummary.id === currentChatId ? 'active' : ''}`;
                        chatLink.setAttribute('data-chat-id', chatSummary.id); // Store chat ID
                        chatLink.setAttribute('data-chat-title', chatSummary.title); // Store chat title

                        const chatTitleSpan = document.createElement('span');
                        chatTitleSpan.textContent = chatSummary.title;
                        chatLink.appendChild(chatTitleSpan);

                        const actionsDiv = document.createElement('div');
                        actionsDiv.className = 'chat-link-actions';

                        const renameBtn = document.createElement('button');
                        renameBtn.className = 'rename-chat-btn';
                        renameBtn.innerHTML = '<i class="fas fa-edit"></i>';
                        renameBtn.title = 'Rename Chat';
                        renameBtn.onclick = (e) => {
                            e.stopPropagation(); // Prevent loading chat when clicking rename
                            renameChat(chatSummary.id, chatSummary.title);
                        };
                        actionsDiv.appendChild(renameBtn);

                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'delete-chat-btn';
                        deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                        deleteBtn.title = 'Delete Chat';
                        deleteBtn.onclick = (e) => {
                            e.stopPropagation(); // Prevent loading chat when clicking delete
                            deleteChat(chatSummary.id, chatSummary.title);
                        };
                        actionsDiv.appendChild(deleteBtn);

                        chatLink.appendChild(actionsDiv);

                        chatLink.onclick = (e) => {
                            e.preventDefault();
                            loadChat(chatSummary.id);
                        };
                        chatHistoryList.appendChild(chatLink);
                    });

                    // Load the most recent chat if no current chat is active
                    const isCurrentChatInList = chatSummaries.some(summary => summary.id === currentChatId);
                    if (!currentChatId || !isCurrentChatInList) {
                        currentChatId = chatSummaries[0].id; // Load the first chat by default
                        await loadChat(currentChatId);
                    } else {
                        await loadChat(currentChatId); // Reload current chat to update active state
                    }
                }
            } catch (error) {
                console.error("Error fetching chat history list:", error);
                addMessage("Failed to load chat history. Please try refreshing.", 'bot', null, new Date());
            }
        }

        async function loadChat(id) {
            const chatbox = document.getElementById('chatbox');
            currentChatId = id;
            chatbox.innerHTML = ''; // Clear chatbox before loading new chat

            try {
                const response = await fetch(`${window.location.origin}/get_chat_messages/${id}`);
                const chatData = await response.json(); 

                chatData.forEach(msg => {
                    const msgTimestamp = msg.timestamp ? new Date(msg.timestamp * 1000) : new Date();
                    if (msg.type === 'bot' && msg.image_urls && msg.image_urls.length > 0) {
                        addMessage(msg.text, msg.type, msg.image_urls, msgTimestamp);
                    } else if (msg.type === 'user' && msg.image_url) { 
                        const imgElement = document.createElement('img');
                        imgElement.src = msg.image_url;
                        imgElement.classList.add('uploaded-image-preview');
                        addMessage(msg.text, msg.type, imgElement, msgTimestamp);
                    } else {
                        addMessage(msg.text, msg.type, null, msgTimestamp);
                    }
                });

                // Update active state in chat history list
                document.querySelectorAll('.chat-link').forEach(link => {
                    link.classList.remove('active');
                });
                const activeLink = document.querySelector(`.chat-link[data-chat-id="${currentChatId}"]`);
                if (activeLink) {
                    activeLink.classList.add('active');
                }

                scrollToBottom();
            } catch (error) {
                console.error(`Error loading chat data for ${id}:`, error);
                addMessage("Failed to load chat. It might have been deleted or corrupted.", 'bot', null, new Date());
            }
        }

        // NEW: Function to rename a chat
        async function renameChat(chatId, currentTitle) {
            const newTitle = prompt(`Rename chat "${currentTitle}":`, currentTitle);
            if (newTitle && newTitle.trim() !== currentTitle) {
                try {
                    const response = await fetch(`${window.location.origin}/rename_chat/${chatId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ new_title: newTitle.trim() }),
                    });
                    const result = await response.json();
                    if (result.status === 'success') {
                        addMessage(`Chat "${currentTitle}" renamed to "${newTitle}".`, 'bot', null, new Date());
                        await updateChatHistory(); // Refresh the sidebar
                    } else {
                        addMessage(`Failed to rename chat: ${result.error}`, 'bot', null, new Date());
                    }
                } catch (error) {
                    console.error("Error renaming chat:", error);
                    const userErrorMessage = error.message.includes('Failed to fetch') ? 
                                               'Could not connect to the server. Please check your network connection and ensure the server is running.' : 
                                               `An unexpected network error occurred: ${error.message}.`;
                    addMessage(`Network error while renaming chat: ${userErrorMessage} Please try again.`, 'bot', null, new Date());
                }
            } else if (newTitle !== null && newTitle.trim() === '') {
                addMessage("Chat title cannot be empty.", 'bot', null, new Date());
            }
        }

        // NEW: Function to delete a chat
        async function deleteChat(chatId, chatTitle) {
            // Use the existing confirm modal for deletion
            const confirmModal = document.getElementById('confirmModal');
            const modalTitle = confirmModal.querySelector('h3');
            const modalParagraph = confirmModal.querySelector('p');
            const confirmBtn = document.getElementById('confirmClearBtn');
            const cancelBtn = confirmModal.querySelector('.modal-btn.cancel');

            modalTitle.textContent = `Delete Chat "${chatTitle}"?`;
            modalParagraph.textContent = `Are you sure you want to delete "${chatTitle}"? This action cannot be undone.`;
            confirmBtn.textContent = 'Delete';
            confirmBtn.classList.remove('confirm'); // Remove 'confirm' class for general clear all
            confirmBtn.classList.add('modal-btn', 'confirm'); // Re-add for delete specific styling

            // Temporarily remove previous listener and add new one for this specific action
            const oldConfirmListener = confirmBtn.onclick;
            confirmBtn.onclick = null; // Clear existing listener
            confirmBtn.addEventListener('click', async function handler() {
                try {
                    const response = await fetch(`${window.location.origin}/delete_chat/${chatId}`, {
                        method: 'POST',
                    });
                    const result = await response.json();
                    if (result.status === 'success') {
                        addMessage(`Chat "${chatTitle}" deleted.`, 'bot', null, new Date());
                        if (chatId === currentChatId) {
                            // If the current chat was deleted, start a new one
                            await startNewChat();
                        } else {
                            await updateChatHistory(); // Refresh the sidebar
                        }
                    } else {
                        addMessage(`Failed to delete chat: ${result.error}`, 'bot', null, new Date());
                    }
                } catch (error) {
                    console.error("Error deleting chat:", error);
                    const userErrorMessage = error.message.includes('Failed to fetch') ? 
                                               'Could not connect to the server. Please check your network connection and ensure the server is running.' : 
                                               `An unexpected network error occurred: ${error.message}.`;
                    addMessage(`Network error while deleting chat: ${userErrorMessage} Please try again.`, 'bot', null, new Date());
                } finally {
                    hideModal();
                    // Restore original confirm button listener if needed, or just keep it null for next use
                    confirmBtn.onclick = oldConfirmListener; 
                    confirmBtn.removeEventListener('click', handler); // Remove this specific handler
                    // Reset modal text to default for clear all chats
                    modalTitle.textContent = `Clear All Chats?`;
                    modalParagraph.textContent = `Are you sure you want to clear all chat history? This action cannot be undone.`;
                    confirmBtn.textContent = 'Clear All';
                    confirmBtn.classList.remove('confirm');
                    confirmBtn.classList.add('modal-btn', 'confirm');
                }
            }, { once: true }); // Use { once: true } to automatically remove listener after first execution

            if (modal) modal.style.display = 'flex';
        }


        // Initialize the app on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', async function () {
            // Apply dark mode if previously enabled
            if (localStorage.getItem('darkMode') === 'enabled') {
                document.body.classList.add('dark-mode');
            }

            // Highlight all existing code blocks on load
            hljs.highlightAll();

            // Initialize Speech Recognition and Visualizer
            initializeSpeechRecognition();
            initializeVoiceVisualizer();

            // Initialize Speech Synthesis Voices
            if ('SpeechSynthesisUtterance' in window && 'speechSynthesis' in window) {
                synth = window.speechSynthesis;
                synth.onvoiceschanged = setAIVoice; // Listen for voices to be loaded
                setAIVoice(); // Call immediately in case voices are already loaded
            } else {
                console.warn("Web Speech Synthesis API not supported.");
                addMessage("Your browser does not support Web Speech Synthesis (AI voice output). Please use a compatible browser like Chrome or Edge.", 'bot', null, new Date());
            }

            // Element References (re-get if needed due to new elements)
            const sidebar = document.getElementById('sidebar');
            const showSidebarBtn = document.getElementById('showSidebarBtn');
            const sidebarToggleButton = document.getElementById('sidebarToggleButton'); // Changed from hideSidebarBtn
            const textInput = document.getElementById('text-input');
            const multiActionForm = document.getElementById('multi-action-form');
            const cameraOptions = document.querySelector('.camera-options');
            const takePhotoInput = document.getElementById('take-photo-input'); // NEW: Get the actual input
            const uploadPhotoInput = document.getElementById('upload-photo-input'); // NEW: Get the actual input
            const cancelCameraBtn = document.getElementById('cancel-camera');
            const clearImageBtn = document.getElementById('clear-image-btn'); // Get clear image button
            const clearAllChatsBtn = document.getElementById('clearAllChatsBtn');
            const confirmClearBtn = document.getElementById('confirmClearBtn');
            const modal = document.getElementById('confirmModal');
            const webSearchBtn = document.getElementById('web-search-btn'); // Get the new web search button
            const sendBtn = document.getElementById('send-btn'); // Reference to the send button
            const stopBtn = document.getElementById('stop-btn'); // Reference to the stop button

            // New: Get radio buttons for model selection
            const modelGeneralRadio = document.getElementById('modelGeneral');
            const modelDeepThinkRadio = document.getElementById('modelDeepThink');
            const fileInputLabel = document.getElementById('file-input-label'); // Retain reference for mobile options

            // Event Listeners for UI interaction
            // Use sidebarToggleButton for collapsing/expanding the sidebar from inside
            if (sidebarToggleButton) sidebarToggleButton.addEventListener('click', toggleSidebar);
            // Use showSidebarBtn for showing the sidebar when it's fully hidden (mobile or desktop full screen)
            if (showSidebarBtn) showSidebarBtn.addEventListener('click', toggleSidebar);

            if (clearImageBtn) clearImageBtn.addEventListener('click', clearImagePreview); // Event listener for clear image button
            if (stopBtn) { // NEW: Add event listener for the stop button
                stopBtn.addEventListener('click', function() {
                    if (abortController) {
                        abortController.abort(); // Abort the ongoing fetch request
                    }
                    showSendButton(); // Immediately show send button
                    document.getElementById('loader').style.display = 'none'; // Hide loader
                    stopSpeaking(); // Stop any ongoing speech
                });
            }

            // Responsive window resize handling
            window.addEventListener('resize', () => {
                // Adjust sidebar and main content behavior on resize
                const mainContent = document.querySelector('.main');
                if (window.innerWidth <= 768) {
                    // On mobile, ensure sidebar is not 'collapsed' but rather 'visible' for slide-out
                    if (sidebar.classList.contains('collapsed')) {
                        sidebar.classList.remove('collapsed');
                        mainContent.classList.remove('full-width');
                    }
                } else {
                    // On desktop, hide floating button if sidebar is open
                    // Restore sidebar visibility based on previous state if on desktop
                    if (!sidebarHidden) { // Only if not manually hidden
                         sidebar.classList.remove('collapsed');
                         mainContent.classList.remove('full-width');
                    }
                }
                updateSidebarToggleButtonVisibility(); // Always call this on resize to ensure correct button state
            });

            // Auto-resize textarea based on content
            if (textInput) {
                textInput.addEventListener('input', () => {
                    textInput.style.height = 'auto'; // Reset height
                    textInput.style.height = (textInput.scrollHeight) + 'px'; // Set to scroll height
                });

                // NEW: Handle Enter key to send message
                textInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault(); // Prevent new line
                        multiActionForm.dispatchEvent(new Event('submit', { cancelable: true })); // Trigger form submission
                    }
                });
            }

            // Handle web search button click
            if (webSearchBtn) {
                webSearchBtn.addEventListener('click', async function() {
                    const userText = textInput.value.trim();
                    if (!userText) {
                        console.error("Please enter a search query.");
                        addMessage("Please enter a search query.", 'bot', null, new Date());
                        if (isVoiceTalkActive) speakText("Please enter a search query.");
                        return;
                    }
                    // Optimistically add user message
                    addMessage(`Searching the web for: "${userText}"`, 'user', null, new Date());
                    
                    const loaderElement = document.getElementById('loader');
                    loaderElement.style.display = 'block'; // Show loader
                    showStopButton(); // Show stop button
                    stopSpeaking(); // Stop AI speech if any

                    try {
                        await performWebSearch(userText);
                    } catch (error) {
                        console.error("Web search button error:", error);
                        addMessage("Sorry, an unexpected error occurred during web search. Please try again.", 'bot', null, new Date());
                        if (isVoiceTalkActive) speakText("Sorry, an unexpected error occurred during web search. Please try again.");
                    } finally {
                        loaderElement.style.display = 'none'; // Hide loader
                        textInput.value = '';
                        textInput.style.height = 'auto';
                        textInput.focus();
                        showSendButton(); // Show send button
                    }
                });
            }

            // Camera options for mobile (take photo/upload from gallery)
            // Show camera options when the plus icon is clicked on mobile
            fileInputLabel.addEventListener('click', function(event) {
                // Prevent direct file input click if on mobile and camera options should appear
                if (/Android|webOS|iPhone|iPad|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                    event.preventDefault(); // Stop default file picker
                    cameraOptions.style.display = 'block';
                }
                // On desktop, the default file input click will proceed (it's hidden but still functional if directly clicked)
            });

            // NEW: Event listeners for the actual hidden file inputs
            if (takePhotoInput) {
                takePhotoInput.addEventListener('change', function() {
                    if (this.files.length > 0) {
                        showImagePreview(this.files[0]);
                        cameraOptions.style.display = 'none'; // Hide options once file is selected
                    } else {
                        clearImagePreview();
                    }
                });
            }

            if (uploadPhotoInput) {
                uploadPhotoInput.addEventListener('change', function() {
                    if (this.files.length > 0) {
                        showImagePreview(this.files[0]);
                        cameraOptions.style.display = 'none'; // Hide options once file is selected
                    } else {
                        clearImagePreview();
                    }
                });
            }

            if (cancelCameraBtn) {
                cancelCameraBtn.addEventListener('click', function() {
                    if (cameraOptions) cameraOptions.style.display = 'none';
                    clearImagePreview(); // Clear preview on cancel
                });
            }

            // Handle form submission based on input content and attached files
            if (multiActionForm) {
                multiActionForm.addEventListener('submit', async function (e) {
                    e.preventDefault(); // Prevent default form submission
                    const loaderElement = document.getElementById('loader');
                    loaderElement.style.display = 'block'; // Show loader for all submission types
                    showStopButton(); // Show stop button on submit
                    stopSpeaking(); // Stop AI speech if any

                    const userText = textInput.value.trim();
                    const modelChoice = document.querySelector('input[name="modelChoice"]:checked').value; // Get selected model
                    
                    // Determine which file input (if any) has a file
                    let selectedFile = null;
                    if (takePhotoInput && takePhotoInput.files.length > 0) {
                        selectedFile = takePhotoInput.files[0];
                    } else if (uploadPhotoInput && uploadPhotoInput.files.length > 0) {
                        selectedFile = uploadPhotoInput.files[0];
                    }
                    const hasFile = selectedFile !== null;

                    try {
                        if (hasFile) {
                            // Assume image upload if a file is present
                            // Add user message with image preview immediately (optimistic update)
                            const imgElementForChat = document.createElement('img');
                            imgElementForChat.src = document.getElementById('image-preview').src; 
                            imgElementForChat.classList.add('uploaded-image-preview');
                            const caption = userText ? `Image with caption: "${userText}"` : 'Uploaded image';
                            addMessage(caption, 'user', imgElementForChat, new Date());
                            
                            // Now call the function that handles backend interaction
                            await uploadImage(selectedFile, userText); 
                        } else {
                            // Check for special commands
                            const lowerCaseText = userText.toLowerCase();

                            if (lowerCaseText.startsWith('generate image of') || 
                                lowerCaseText.startsWith('create an image of') ||
                                lowerCaseText.startsWith('picture of') ||
                                lowerCaseText.startsWith('draw a') ||
                                lowerCaseText.startsWith('make an image of')) {
                                addMessage(userText, 'user', null, new Date()); // Add user text message immediately
                                await generateImage(userText);
                            } else if (lowerCaseText.startsWith('explain code')) {
                                addMessage(userText, 'user', null, new Date());
                                await explainCode(userText.replace('explain code', '').trim());
                            } else if (lowerCaseText.startsWith('grammar check')) {
                                addMessage(userText, 'user', null, new Date());
                                await checkGrammarAndStyle(userText.replace('grammar check', '').trim());
                            } else if (lowerCaseText.startsWith('show html code') || lowerCaseText.startsWith('show app html')) {
                                addMessage("Requesting application HTML code...", 'user', null, new Date());
                                const response = await fetch(`${window.location.origin}/get_app_html`);
                                const htmlCode = await response.text(); // Get raw text HTML
                                
                                loaderElement.style.display = 'none';
                                showSendButton(); // Show send button

                                // Directly add the code block without a preview button
                                addMessage("Here is the current HTML code for the AI Assistant app:", 'bot', null, new Date());
                                // Create a new message element specifically for the code block
                                const codeMessage = document.createElement('div');
                                codeMessage.className = `chat-message bot-message pulse`;
                                const codeContentDiv = document.createElement('div');
                                codeContentDiv.className = 'message-content';
                                // The crucial change: Marked.js will handle the escaping within the code block
                                // because the 'renderer.code' function now re-escapes the content.
                                codeContentDiv.innerHTML = marked.parse(`\`\`\`html\n${htmlCode}\n\`\`\``); 
                                codeMessage.appendChild(codeContentDiv);
                                document.getElementById('chatbox').appendChild(codeMessage);
                                scrollToBottom();
                                hljs.highlightAll(); // Re-highlight all code blocks

                                if (isVoiceTalkActive) speakText("Here is the current HTML code for the AI Assistant app.");

                            }
                            else if (!userText) {
                                console.error("Please enter your input.");
                                addMessage("Please enter your input.", 'bot', null, new Date());
                                if (isVoiceTalkActive) speakText("Please enter your input.");
                                return;
                            }
                            else {
                                // Default to Ask AI
                                addMessage(userText, 'user', null, new Date()); // Add user text message immediately
                                await askAI(userText, modelChoice); // Pass modelChoice
                            }
                        }
                    } catch (error) {
                        console.error("Submission error:", error);
                        addMessage("Sorry, an unexpected error occurred. Please try again.", 'bot', null, new Date());
                        if (isVoiceTalkActive) speakText("Sorry, an unexpected error occurred. Please try again.");
                    } finally {
                        loaderElement.style.display = 'none';
                        textInput.value = '';
                        textInput.style.height = 'auto';
                        textInput.focus();
                        clearImagePreview();
                        showSendButton(); // Ensure send button is shown after any submission type
                    }
                });
            }

            // Clear all chats confirmation and action
            if (clearAllChatsBtn) {
                clearAllChatsBtn.addEventListener('click', function() {
                    // Reset modal to "Clear All Chats" default before showing
                    const modalTitle = modal.querySelector('h3');
                    const modalParagraph = modal.querySelector('p');
                    const confirmBtn = document.getElementById('confirmClearBtn');

                    modalTitle.textContent = `Clear All Chats?`;
                    modalParagraph.textContent = `Are you sure you want to clear all chat history? This action cannot be undone.`;
                    confirmBtn.textContent = 'Clear All';
                    confirmBtn.classList.remove('confirm'); // Ensure it has default confirm styling
                    confirmBtn.classList.add('modal-btn', 'confirm');

                    // Remove any previous specific delete handler and add the general clear all handler
                    confirmBtn.onclick = null; // Clear previous listeners
                    confirmBtn.addEventListener('click', async function handler() {
                        try {
                            const response = await fetch(`/clear_all_chats`, { method: 'POST' });
                            const result = await response.json();

                            if (result.status === 'success') {
                                currentChatId = null; // Reset current chat ID
                                document.getElementById('chatbox').innerHTML = ''; // Clear chat messages
                                addMessage("All chat history cleared. How can I help you?", 'bot', null, new Date());
                                if (isVoiceTalkActive) speakText("All chat history cleared. How can I help you.");
                                await updateChatHistory(); // Refresh sidebar history
                                if (modal) modal.style.display = 'none';
                            } else {
                                console.error("Failed to clear chats:", result.error || "Unknown error.");
                                addMessage("Failed to clear chats. Please try again.", 'bot', null, new Date());
                                if (isVoiceTalkActive) speakText("Failed to clear chats. Please try again.");
                            }
                        } catch (error) {
                            console.error("Network error while clearing chats:", error);
                            addMessage("Network error while clearing chats. Please try again.", 'bot', null, new Date());
                            if (isVoiceTalkActive) speakText("Network error while clearing chats. Please try again.");
                        } finally {
                            if (modal) modal.style.display = 'none';
                            confirmBtn.removeEventListener('click', handler); // Remove this specific handler
                        }
                    }, { once: true }); // Use { once: true } to automatically remove listener after first execution

                    if (modal) modal.style.display = 'flex';
                });
            }

            // Initial setup on page load
            await updateChatHistory(); // Load existing chat history or start new chat
            
            // Fetch user info (assuming a /user_info endpoint)
            fetch('/user_info')
                .then(response => response.json())
                .then(data => {
                    const userInfoDiv = document.getElementById('user-info');
                    const userEmailSpan = document.getElementById('user-email');
                    if (data.user_email) {
                        userEmailSpan.textContent = data.user_email;
                        userInfoDiv.style.display = 'flex'; // Show user info if email exists
                    } else {
                        userInfoDiv.style.display = 'none';
                    }
                })
                .catch(error => console.error('Error fetching user info:', error));
            
            // Initial desktop sidebar state
            if (window.innerWidth > 768) {
                sidebar.classList.remove('collapsed');
                mainContentElement.classList.remove('full-width');
                sidebarHidden = false; // Sidebar starts open
            }
            updateSidebarToggleButtonVisibility(); // Set initial button visibility correctly
        });
    </script>
</body>
</html>
